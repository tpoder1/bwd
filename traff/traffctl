#!/usr/bin/perl -w
use strict;

use Getopt::Std;
use Data::Dumper;
use POSIX qw(strftime);
use DBI;
use File::Basename;

my $METASTR	= "#{0,1}\@shaper";
my $SOURCEFILE = "/etc/traffd/traffic.cfg";
my $DATAFILE = "/etc/traffd/traffic.db";
my $DUMPFILE = "/var/spool/traffd";
my $DEBUG = 0;
my $MULT = 1000*1000; # baseu units (megabits)


my %OPTS;		# Options from command line
my $DBH;
my %GROUPS;


sub db_connect() {

	$DBH = DBI->connect("dbi:SQLite:dbname=$DATAFILE");

	if (!$DBH) {
		printf("Can't open to datafile %s (%s).\n", $DATAFILE,  $DBI::errstr);
		return 0;
	}

	return 1;
}


# initialise empty database file 
sub db_init {
	my ($datafile, @cols) = @_;


	my $sql = "
			CREATE TABLE IF NOT EXISTS ipaddr (
			ipaddr		CHAR(90),
			grp 		CHAR(100),
			parent 		CHAR(100),
			download	int NOT NULL,
			upload		int NOT NULL,
			mark		int ,
			to_delete	int NOT NULL,
			UNIQUE(ipaddr, parent))
			";

	$DBH->do('BEGIN TRANSACTION');

	if (!$DBH->do($sql)) {
		printf("Can't create emty database.\n", $DATAFILE,  $DBI::errstr);
		return 0;
	}

	if (!$DBH->do("UPDATE ipaddr SET to_delete = 1")) {
		printf("Can't set to_delete\n", $DATAFILE,  $DBI::errstr);
		return 0;
	}

	return 1;
}

sub db_rule($$$$$$) {
	my ($ip, $group, $down, $up, $mark, $parent) = @_;

	my $rows;	

#	if (!defined($group)) {
#		$group = "";
#		$group .= sprintf("%x", rand 16) for 1..18;
#	}
#	

	my $sql = "INSERT OR IGNORE INTO ipaddr (ipaddr, grp, download, upload, mark, parent, to_delete) 
				VALUES (?, ?, ?, ?, ?, ?, 0)";
	
	if (! ($rows = $DBH->do($sql, undef, $ip, $group, $down, $up, $mark, $parent)) ) {
		printf("Can't update record for %s in db.\n", $ip, $DBI::errstr);
		return 0;
	}

	if ($rows > 0 ){
		printf("New record %s %d %d [0x%x] %s\n", 
			defined($ip) ? $ip : "group=".$group,
			$down, $up, $mark, defined($parent) ? "parent=".$parent : "");
		return 1;
	}

	$sql = "UPDATE ipaddr SET download = ?, upload = ?, grp = ?, mark = ?, to_delete = 0 
			WHERE ipaddr = ? and (download != ? or upload != ? or grp != ? or mark != ?)";

	if (! ($rows = $DBH->do($sql, undef, $down, $up, $group, $mark, $ip, $down, $up, $group, $mark)) ) {
		printf("Can't update record for %s in db.\n", $ip, $DBI::errstr);
		return 0;
	}

	if ($rows > 0 ){
		printf("Updated record %s %d %d [0x%x] %s\n", 
		 	defined($ip) ? $ip : "group=".$group,
			$down, $up, $mark, defined($parent) ? "parent=".$parent : "");
		return 1;
	}

	$sql = "UPDATE ipaddr SET to_delete = 0 WHERE ipaddr = ?";
	if (! ($rows = $DBH->do($sql, undef, $ip)) ) {
		printf("Can't update record for %s in db.\n", $ip, $DBI::errstr);
		return 0;
	}

	return 1;
}

# print group where parent is $parent
sub print_grp {
	my ($parent, $db) = @_;

	foreach my $grp (sort { $a cmp $b } keys %{$db}) {

		next if (defined($parent) && !defined($db->{$grp}->{PARENT}));
		next if (!defined($parent) && defined($db->{$grp}->{PARENT}));
		next if (defined($parent) && defined($db->{$grp}->{PARENT}) && $parent ne $db->{$grp}->{PARENT});

		my $iplist = "" ;

		if (defined($db->{$grp}->{IP})) {

			$iplist = join(",", @{$db->{$grp}->{IP}});
		}
		printf "%-20s %4d %4d 0x%03x 0x%03x 0x%03x %s\n", 
			("  " x $db->{$grp}->{DEEP}).$grp, 
			$db->{$grp}->{DOWNLOAD} / 1000 / 1000, $db->{$grp}->{UPLOAD}/ 1000/ 1000,
			$db->{$grp}->{DOWNLOAD_ID},
			$db->{$grp}->{UPLOAD_ID},
			$db->{$grp}->{MARK},
			$iplist;
		
		print_grp($grp, $db);
	}
}

sub db_dump() {

	if ( ! -f $DUMPFILE ) {
		printf "Can't open traffd dump file %s\n", $DUMPFILE;
		exit(1);
	}

	our $VAR1 = undef;

	do $DUMPFILE;
	my $db = $VAR1;

	printf "GROUP                DOWN   UP  D_ID  U_ID  MARK IP(s)\n";

	print_grp(undef, $db);
#	printf Dumper($VAR1);
}

sub db_query_dump() {

	my $tbh = $DBH->prepare("SELECT ipaddr, download, upload, grp, mark, parent FROM ipaddr ORDER BY ipaddr");

	if (!$tbh->execute()) {	
		printf("Can't dumb database.\n", $DBI::errstr);
		return 0;
	}

	printf("%-25s -> %5s      %5s      %s\n", "IP ADDR", "UP", "DOWN", "OPTS");
	while (my ($ip, $up, $down, $group, $mark, $parent) = $tbh->fetchrow_array()) {

		printf("%-25s -> %5.1f Mb/s %5.1f Mb/s mark=0x%x group=%s %s\n", 
			defined($ip) ? $ip : "group=".$group,
			$up / 1000 / 1000, $down / 1000 / 1000, $mark, 
			defined($group) ? $group : $ip, 
			defined($parent) ? "parent=".$parent : "");

	}
}

sub db_finish {

	my $rows;

	if (!($rows = $DBH->do("DELETE FROM ipaddr WHERE to_delete = 1"))) {
		printf("Can't delete old records\n", $DATAFILE,  $DBI::errstr);
		return 0;
	}

	if ($rows > 0 ){
		printf("Removed %d record(s).\n", $rows);
	}

	$DBH->commit;
	return 1;
}

sub parse_config($) {
	my ($config) = @_;

	my $lineno = 0;
	my %defines;

	open F1, "< $config";

	while (<F1>) {
		$lineno++;
		chomp;

		my ($com, $atts) = split(/$METASTR/, $_);
		# skip lines without metatag
		next if (!defined($atts) || $atts eq "");

#		printf("ATTS: '%s'\n", $atts);

		$atts =~ s/^\s+//;
		my ($cmd, @arg) = split(/[\s,=]+/, $atts);

		if ($cmd eq "define") {

#			printf("def '%s' -> '%s'\n", $arg[0], $arg[1]);
			$defines{$arg[0]} = $arg[1];

		} elsif ($cmd eq "rule") {
	
			my %atts;
			$atts{'mark'} = 0;
			$atts{'group'} = undef;
			$atts{'parent'} = undef;
#			printf("Rule: %s\n", join(" : ", @arg));

			for (my $x = 0; $x < @arg - 1; $x++, $x++ ) {
				my $key = $arg[$x];
				my $val = $arg[$x+1];

				if ( defined($defines{$val}) ) { $val = $defines{$val}; }
				
				$atts{$key} = $val;
#				printf("%s -> %s\n", $key, $val);
			}

			# check attributes 
			if (!defined($atts{'download'})  || !defined($atts{'upload'})) {
				printf("Missing upload/download attribute on line %d.\n", $lineno);
				return 0;
			}
			if ($atts{'download'} !~ /^\d+$/ || $atts{'upload'} !~ /^\d+$/) {
				printf("Invalid upload/download attribute on line %d.\n", $lineno);
				return 0;
			}
			if (defined($atts{'group'})) {
				$GROUPS{$atts{'group'}} = 1;
			}
			if (defined($atts{'parent'})) {
				if (!defined($GROUPS{$atts{'parent'}})) {
					printf("Parent '%s' uses unexisting group on line %d.\n", $atts{'parent'}, $lineno);
					return 0;
				}
			}
			if (!defined($atts{'ip'}) && !defined($atts{'group'})) {
				printf("Missing ip or group attribute on line %d.\n", $lineno);
				return 0;
			}
			if ($atts{'mark'} =~ /0x[\d+|a-f|A-F]+$/) {
				$atts{'mark'} = hex $atts{'mark'};
			}
			if ($atts{'mark'} !~ /^\d+$/) {
				printf("Invalid mark attribute on line %d (must be number).\n", $lineno);
				return 0;
			}
			
			my $ret = db_rule($atts{'ip'}, $atts{'group'}, $atts{'download'} * $MULT , $atts{'upload'} * $MULT, $atts{'mark'}, $atts{'parent'}); 

			if (!$ret) {
				return 0;
			}

		} else {
			printf("Unknown command %s on line %d\n", $cmd, $lineno);
			return 0;
		}

	}

	close F1;

	return 1;
}

# help
sub usage() {
	printf "config sync control\n";
	printf "Usage:\n";
	printf "    %s [ -d <debug_level> ] [ -q ] [ -l ] \n\n", $0;
	printf " -q : dump sql database \n";
	printf " -l : dump internal traffd database \n";
	exit 1;
}

if (!getopts("d:lq", \%OPTS) || defined($OPTS{"?"})) {
	usage();	
	exit 1;
}

if (defined($OPTS{"d"})) {
	$DEBUG = $OPTS{"d"};
}

db_connect() || die "Exiting...";
db_init() || die "Exiting...";

if (defined($OPTS{"q"})) {
	db_query_dump();
} elsif (defined($OPTS{"l"})) {
	db_dump();
} else {

	if ( ! -f $SOURCEFILE ) {
		die "Can't find input file $SOURCEFILE\n";
	}

	if (!parse_config($SOURCEFILE)) {
	
		printf "Configuration not updated!\n";
	} else {
		system('kill -HUP $(cat /var/run/traffd.pid)');
	}
	db_finish() || die "Exiting...";
}


#db_dump();

