#!/usr/bin/perl  

#my $CONFIG		= "bwd.conf";	# config file
my $CONFIG		= ( -f "./traffd.conf" ) ? "./traffd.conf" : "/etc/traffd/traffd.conf";	# config file
my $LOGNAME		= substr($0, rindex($0, "/") + 1);;
my $LOGFACILITY	= "daemon.info";
my $DEBUG 		= 1;

use DBI;
use Data::Dumper;
use Getopt::Std;
use POSIX;
use Sys::Syslog qw(:DEFAULT setlogsock);
use strict;

my $DBH;		# database handler
my %RULEDB;		# rule database
our %TRAFFD_CONF;	# content of configuration file 
my %ID;			# allocated IDs
my %OPTS = ( 'p' => '/var/run/traffd.pid' ); # options
my $TERMNATE = 0;




#
#open F1, ">> /tmp/log";
#printf F1 "%s\n", join(":", @ARGV);
#close F1;

# logging rutine
sub mylog {
	my ($msg, @par) = @_;
	my $lmsg = sprintf($msg, @par);
	if ($DEBUG > 0) {
		printf "%s[%d]: %s\n", strftime("%Y-%m-%d.%H:%M:%S", localtime), $$, $lmsg;
	}
	setlogsock('unix');
	openlog("$LOGNAME\[$$\]", 'ndelay', 'user');
	syslog($LOGFACILITY, $lmsg);
}


# connect or reconnect database 
sub db_connect() {

	if ( defined($TRAFFD_CONF{'database'}) ) {

		my($driver, $server, $db, $user, $password) = split(/;/, $TRAFFD_CONF{'database'});
		my $dsn;

		if ($driver eq "mysql") {
			$dsn = "DBI:mysql:$db:$server";
		} elsif ($driver eq "pgsql") {
			$dsn = "DBI:Pg:dbname=$db;host=$server";
		} elsif ($driver eq "sqlite") {
			$dsn = "dbi:SQLite:dbname=$db";
		}

		mylog("Connecting DB: %s,%s,*password*", $dsn, $user) if ($DEBUG > 0); 

		if (!($DBH = DBI->connect($dsn, $user, $password, {'PrintError'=>0}))) {

			mylog("Can't connect to SQL server: %s.", $DBI::err);
			return 0;

		}  else {

			return 1;

		}

	} else {

		mylog("Database connection string not defined.");
		return 0;

	}
}

sub rec_cmp($$) {
	my ($r1, $r2) = @_;

	# big change 
	return 2 if (defined($r1->{PARENT}) && !defined($r2->{PARENT}));
	return 2 if (!defined($r1->{PARENT}) && defined($r2->{PARENT}));
	if (defined($r1->{PARENT}) && defined($r2->{PARENT})) {
		return 2 if ($r1->{PARENT} ne $r2->{PARENT});
	}
	return 2 if ($r1->{GROUP} ne $r2->{GROUP});
	return 2 if ($r1->{DEEP} ne $r2->{DEEP});
	return 2 if (defined($r1->{IP}) && !defined($r2->{IP})); 
	return 2 if (!defined($r1->{IP}) && defined($r2->{IP})); 

	if (defined($r1->{IP}) && defined($r2->{IP})) {
		return 2 if (@{$r1->{IP}} != @{$r2->{IP}});
		foreach (@{$r1->{IP}}) {
			return 2 if ($r1->{IP}->[$_] ne $r2->{IP}->[$_]);
		}
	}

	# only small change in upload or download 
	return 1 if ($r1->{DOWNLOAD} != $r2->{DOWNLOAD});
	return 1 if ($r1->{UPLOAD} != $r2->{UPLOAD});
	return 0;
}

# perform action (execute command)
sub action_cmd($$) {

	my ($action, $rec) = @_;

	if (!defined($TRAFFD_CONF{'callbacks'}->{$action})) {

		mylog("No callback defined for action %s", $action);
		return 0;

	}

	my $callback = $TRAFFD_CONF{'callbacks'}->{$action};

	if ( ! -x $callback ) {
		mylog("Script %s not foud or can't be executed", $callback);
		return 0;
	}

	my $cmd = sprintf("%s %s ", $callback, $action);
	if (defined($rec)) {
		$cmd .= rec_str($rec);
	}

	if (! open CMD, "$cmd 2>&1|" ) { 
		mylog("Can't execute command: %s", $cmd);
		return 0;
	} else {
		my $out = join("", <CMD>);

		$out =~ s/[^[:print:]]+//g;
		$out =~ s/\n//g;
		$out =~ s/\[\?1034h//g;

		if ( defined($out) && $out ) {
			mylog("CMD output: '%s' cmd: %s", $out, $cmd);
		}
	}

	return 1;
}


# gent next free ID
sub get_id() {

	my $id = $TRAFFD_CONF{'first_id'};

	while (defined($ID{$id})) {
		$id++;	
	}	
	
	$ID{$id} = 1;	
	return $id;
}

sub free_id($) {
	my ($id) = @_;

	delete($ID{$id});	

}


sub rec_str($) {
	my ($rec) = @_;

	my $d = $rec->{DOWNLOAD};
	my $u = $rec->{UPLOAD};

	my $did = $rec->{DOWNLOAD_ID};
	my $uid = $rec->{UPLOAD_ID};

	my $pdid = 0;
	my $puid = 0;
	if (defined($rec->{PARENT})) {
		my $p = $rec->{PARENT};
		$pdid = $RULEDB{$p}->{DOWNLOAD_ID};
		$puid = $RULEDB{$p}->{UPLOAD_ID};
	}

	$d = $TRAFFD_CONF{'default_bw'} if (!defined($d) || $d == 0);
	$u = $TRAFFD_CONF{'default_bw'}  if (!defined($u) || $u == 0);

	my $ip = "";
	if (defined($rec->{IP})) { 
		$ip = join(" ", @{$rec->{IP}});
	}

	
		
	return sprintf("%x %x %x %x %d %d %x %s", $did, $uid, $pdid, $puid, $d, $u, 
									$rec->{MARK}, $ip);
	
}

# reload data structure in DB 
sub db_dump() {

	my $dumpdb = $TRAFFD_CONF{'dump_db'};

	return if (!defined($dumpdb) && $dumpdb eq '');

	open DDB, ">$dumpdb";	
	print DDB Dumper(\%RULEDB);
	close DDB;
}



# reload data structure in DB 
sub db_reload() {

	my $tbh;
	my %db;
	my $updated = 0;


	my $query = $TRAFFD_CONF{'scan_query'};

	if (!defined($DBH) || !($tbh = $DBH->prepare($query)) ) {
		mylog("Can't prepare query \'%s\', %s.\n", $query, $DBI::errstr);
		return undef;

	}

	if (!defined($tbh) || !$tbh->execute()) {
		mylog("Can't execute query \'%s\', %s.\n", $query, $DBI::errstr);
		return undef;
	}

    while (my ($ip, $grp, $down, $up, $mark, $parent) = $tbh->fetchrow_array()) {

		# group is not defined 
		$grp = $ip if (!defined($grp) || $grp eq '');
		# mark is not defined 
		$mark = 0 if (!defined($mark));

		# parent is not defined or empty
		$parent = undef if (!defined($parent) || $parent eq '');

		$db{$grp}->{DOWNLOAD} = $down;
		$db{$grp}->{UPLOAD} = $up;
		$db{$grp}->{MARK} = $mark;
		$db{$grp}->{PARENT} = $parent;
		if (defined($ip) && $ip ne '') {
			push(@{$db{$grp}->{IP}}, $ip);
		}
    }

	# verify whether parent links to existing group and assign depth
	my $done = 0;
	while (!$done) {
		$done = 1;
		foreach my $grp (keys %db) {
			# ignore records where parent is not defined 
			if (!defined($db{$grp}->{PARENT})) {
				$db{$grp}->{DEEP} = 0;
				next;
			}

			my $parent = $db{$grp}->{PARENT};
			if (defined($db{$parent})) {
				if (defined($db{$parent}->{DEEP})) {
					$db{$grp}->{DEEP} = $db{$parent}->{DEEP} + 1;
				} else {
					$done = 0;
				}
			} else {
				mylog("Non-existent parent group for record %s", rec_str( \%{$db{$grp}} ));
				$db{$grp}->{PARENT} = undef;
				$db{$grp}->{DEEP} = 0;
				$done = 0;
			}
		}
	}

	# find deleted or changed records 
	# we start the most eepe node
	foreach (sort { $RULEDB{$b}->{DEEP} cmp $RULEDB{$a}->{DEEP} } keys %RULEDB) {
		if ( ! defined($db{$_}) ) {

			mylog("Deleted record: %s", rec_str( \%{$RULEDB{$_}} ));
			action_cmd("del", \%{$RULEDB{$_}});

			free_id($RULEDB{$_}->{DOWNLOAD_ID});
			free_id($RULEDB{$_}->{UPLOAD_ID});
			delete($RULEDB{$_});
			$updated = 1;
		} else {
			# check modified records 
			my $cmp = rec_cmp(\%{$db{$_}}, \%{$RULEDB{$_}});
			if ( $cmp == 1) {
				# simple change 

				$db{$_}->{DOWNLOAD_ID} = $RULEDB{$_}->{DOWNLOAD_ID};
				$db{$_}->{UPLOAD_ID} = $RULEDB{$_}->{UPLOAD_ID};

				mylog("Modified record: %s", rec_str( \%{$db{$_}} ));
				action_cmd("upd", \%{$db{$_}});

				($RULEDB{$_}) = ($db{$_});
				
				delete($db{$_});
				$updated = 1;

			} elsif ($cmp == 2) {

				mylog("Deleted modified record: %s", rec_str( \%{$RULEDB{$_}} ));
				action_cmd("del", \%{$RULEDB{$_}});

				free_id($RULEDB{$_}->{DOWNLOAD_ID});
				free_id($RULEDB{$_}->{UPLOAD_ID});
				delete($RULEDB{$_});
				$updated = 1;

			} else {
				# no change 
				delete($db{$_});
			}
		}
		
	}

	# fiind new modified records 
	foreach (sort { $db{$a}->{DEEP} cmp $db{$b}->{DEEP} } keys %db) { 
		$db{$_}->{DOWNLOAD_ID} = get_id();
		$db{$_}->{UPLOAD_ID} = get_id();
		mylog("Added record: %s", rec_str( \%{$db{$_}} ));
		action_cmd("add", \%{$db{$_}} );
		##### CMD
		($RULEDB{$_}) = ($db{$_});
		delete($db{$_});
		$updated = 1;
	}

	return $updated;

}

sub daemonize() {
	fork and exit;
	POSIX::setsid();
	fork and exit;
	umask 0;
#	chdir '/tmp';
	open STDIN , '<', '/dev/null';
	open STDOUT, '>', '/dev/null';
	open STDERR, '>', '/dev/null';
	open PID, "> ".$OPTS{'p'};
	printf PID "%d\n", $$;
	close PID;
}

sub terminate() {

	mylog("Terminating proccess and cleaning up");
	action_cmd("fin", undef);
	mylog("Tterminated");
	unlink($OPTS{'p'});
	exit(0);
}


# help
sub usage() {
	printf "bandwidth shaping daemon\n";
	printf "Usage:\n";
	printf "    %s -d <debug_level> -c <config_file> -F\n", $0;
	printf " -d <debug_level> : default 0 \n";
	printf " -c <config_file> : default /etc/bwd/bwd.conf \n";
	printf " -F do not run process to backgroud \n";
	printf " -p pidfile (default /var/run/traffd.pid) \n";
	exit 1;
}



if (!getopts("d:c:F?p:", \%OPTS) || defined($OPTS{"?"})) {
    usage();
    exit 1;
}

if (defined($OPTS{"d"})) {
	$DEBUG = $OPTS{"d"};
}

if (! (defined($OPTS{"F"}) && $OPTS{"F"}) ) {
	daemonize();
#	$SIG{'CHLD'} = sub { wait(); };
}

if (defined($OPTS{"c"})) {
	$CONFIG = $OPTS{"c"};
}


$SIG{'INT'} = sub { terminate(); };
$SIG{'QUIT'} = sub { terminate(); };;
$SIG{'TERM'} = sub { terminate(); };;
$SIG{'KILL'} = sub { terminate(); };;
#$SIG{'KILL'} = &terminate;


require  "$CONFIG";

mylog("Starting");
if (!action_cmd("ini", undef)) {
	mylog("Exiting...");
	exit(1);
}



while (1) { 

	# reconenct DB if it is nescessary 
	if (!defined($DBH) || !$DBH->ping) { 
		db_connect();
	}

	action_cmd("chk", undef);
	my $updated = db_reload();
	if (defined($updated) && $updated > 0) {
		db_dump();
	}
	sleep($TRAFFD_CONF{'scan_time'});

}

