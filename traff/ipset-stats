#!/usr/bin/perl -w
use strict;

use Getopt::Std;
use Data::Dumper;
use POSIX qw(strftime);
use DBI;
use File::Basename;

my $IPSET = "/usr/local/sbin/ipset";
my $STATSFILE = "/var/run/ipset-stats";
my $DEBUG = 0;


my %OPTS = ('b' => 1, 'i' => 2, 'n' => 20, 'm' => 0);		# Options from command line
my $DBH;
my %C;
my $LC;




sub load_counters() {

	open F1, "$IPSET list |";

	my $setname = undef;

	while (<F1>) {
		if (/^Name: (.+)$/) {
			$setname = $1;
		}
		if (/^([\d\.\:\/]+) packets (\d+) bytes (\d+)/ && defined($setname)) {
			my ($addr, $pkts, $bytes) = ($1, $2, $3);
			my $key = "$setname $addr";
			$C{$key}->{TIME} = time();
			$C{$key}->{BYTES} = $bytes;
			$C{$key}->{PKTS} = $pkts;
		}
	}
	close F1;
}

sub store_stats() {

	open F1, ">$STATSFILE\n";
	print F1 Dumper(\%C);
	close F1;

}

sub load_stats() {

	return if ( ! -r $STATSFILE );

	open F1, "<$STATSFILE\n";
	my $VAR1;
	eval(join("", <F1>));
	$LC = $VAR1;
	close F1;

}

sub get_diff($$) {
	my ($key, $type) = @_;

	if (defined($C{$key}->{TIME}) && defined($LC->{$key}->{TIME})) {
		my $delta = $C{$key}->{$type} - $LC->{$key}->{$type};
		my $time = $C{$key}->{TIME} - $LC->{$key}->{TIME};
		if ($delta >= 0) {
			return ($delta, $delta / $time);
		}
	} 

	return (undef, undef);
	
}

sub sort_func {

	if ($OPTS{'p'}) {
		$C{$b}->{PKTS} <=> $C{$a}->{PKTS};
	} else {
		$C{$b}->{BYTES} <=> $C{$a}->{BYTES};
	}
}

sub hval($) {
	my ($val) = @_;

	if (!defined($val)) {
		return  sprintf "--";
	} elsif ($val > 1500 * 1500) {
		return  sprintf "%4.1fM", $val / 1000 / 1000;
	} elsif ($val > 1500) {
		return  sprintf "%4.1fk", $val / 1000;
	} else {
		return  sprintf "%4.1fk", $val;
	}
}

sub init_output() {
	
	if ($OPTS{'m'}) { 
	} else {
		printf "+-------------------------------------+-------------------+-------------------+\n"; 
		printf "|%-12s  %-22s | %8s %8s | %8s %8s |\n", "SET", "IP", "b/s" , "B", "p/s", "p";
		printf "+-------------------------------------+-------------------+-------------------+\n"; 
	}
}

sub finish_output() {
	
	if ($OPTS{'m'}) { 
	} else {
		printf "+-------------------------------------+-------------------+-------------------+\n"; 
	}
}
sub format_output($$$$$) {
	my ($key, $Bps, $B, $pps, $p) = @_;
	
	if ($OPTS{'m'}) { 
		printf "%10s %.2f %d %.2f %d\n", $key , $Bps * 8, $B, $pps, $p;

	} else {
		my ($set, $ip) = split(/ /, $key);
		printf "|%-12s  %-22s | %8s %8s | %8s %8s |\n", $set, $ip, hval($Bps * 8) , hval($B), hval($pps), hval($p);

	}
}


sub print_diff() {

	my $cnt = 0;
	foreach my $key (sort sort_func keys %C) {

		my ($B, $Bps) = get_diff($key, 'BYTES');
		my ($p, $pps) = get_diff($key, 'PKTS');

		if (defined($Bps) && defined($B) && defined($pps) && defined($p)) {
			format_output($key, $Bps, $B, $pps, $p);
		}

		last if ($OPTS{'n'} > 0 && $cnt++ > $OPTS{'n'});
	}
}

if ( !getopts('bpi:n:m', \%OPTS) ) {

	printf "Options:\n";
	printf " -b : sort by bytes (default)\n";
	printf " -p : sort by packets\n";
	printf " -i : interval (default 2s)\n";
	printf " -n : number of top records to print (default 20)\n";
	printf " -m : machine output\n";
	exit(1);
}

for (;;) { 

	load_counters();

	if ($OPTS{'i'} == 0) {
		load_stats();
	} else {
		system("tput clear");
	}

	init_output();
	print_diff();

	finish_output();

	if ($OPTS{'i'} == 0) {
		store_stats();
	} else {
		my $x =  Dumper(\%C);
		my $VAR1;
		eval(join("", $x));
		$LC = $VAR1;
	}
	
	

	last if ($OPTS{'i'} == 0);
	sleep($OPTS{'i'});
}


