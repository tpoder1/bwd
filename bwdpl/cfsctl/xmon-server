#!/usr/bin/perl -w
use strict;

#$| = 0;

my $PORT		= "3314";
my $QUEUERUN	= "10";							# run queue every x munutes
my $VERSION		= "2011-04-27.01";
my $UMASK		= 0777;							# umask pro nove vytvarene adresare
my $QUEUEDIR	= "/var/cache/xmon-server";		# queue for incomming data
my $QUEUELIMIT	= 350000;						# maximum records loaded from queue on one step

# README:
# Daemon posloucha na portu $PORT a prijima spojeni. Vstupni data jsou ve formatu
# DATA <jmeno_zarizeni> atribut:hodnota atribut:hodnota ...  oddelovacem je tabelator (\t)
# jeden z atribudu by mel byt TIMESTAMP jehoz hodnota urcuje timestamp vuci ketremu se
# vztahuji data
#
# Zpusob ukladani dat a jejich dalsi zachazni popisuje definice mapovani 
# atributu v souboru  $ATTMAP
#
# Priklad vstupnich dat:
#
#DATA	hp-pur.5	IN_PKTS:69192135	OUT_OCTETS:229970874	IN_OCTETS:3804236604	OUT_PKTS:69183598	TIMESTAMP:1181812175
#DATA	fw-ant.ipt:10	PKTS:69192135	OCTETS:22997087	TIMESTAMP:1181812175
#DATA	fw-ant.eth0	PKTS:69192135	OCTETS:22997087	TIMESTAMP:1181812175
#DATA	ups-ant	TEMPERATURE:23	TIMESTAMP:1181812175
#

# DEBUG LEVELS:
# 000 - only errors
# 005 - show client connect info
# 010 - show queue process info
# 015 - show metadata create and modification info
# 020 - show database connect, disconnect info
# 025 - show show data manipulation info
# 030 - show all SQL modification commands
# 035 - show all SQL select commands

# moduly
use lib '/usr/local/net/lib';
use lib '/usr/local/lib';
use xmon;
use Getopt::Std;
use Data::Dumper;
use IO::Socket;
#use POSIX ":sys_wait_h";
use POSIX qw(strftime);
use DBI;
use File::Basename;
use MIME::Base64;


my %OPTS;		# Options from command line
my %QDATA;		# data prepared to store ident->timestamp->field
my %STRUCTCACHE;	# data files structure case (inforamtion about existing rows)

###########################################################################################
# VERSION 2 STORAGE ENGINE                                                                #
###########################################################################################

# debug rutine
sub debug {
	my ($level, $msg, @arg) = @_;

	mylog("D $msg", @arg) if ($DEBUG >= $level);
}


# Do SQL query
sub sqldo {
	my ($dbh, $sql, @par) = @_;

	my $q = sprintf($sql, @par);
	debug(30, "SQL: `$q`.");
	if (!defined($dbh)) {
		mylog("Database handler is close. Can't execute SQL query `%s`.", $q);
		return 0;
	}
	if (!$dbh->do($q)) {
		# get database name 
		mylog("Can't execute SQL query on %s (`%s`).", $dbh->{private_datafile}, $DBI::errstr);
		return 0;
	}
	return 1;
}


# Create intermediate directory structure for datafile (if is it nescesary)
sub mkdatadir($) {
	my ($file) = @_;

	my $dir = dirname($file);

	if ( ! -d "$dir" ) {
		my @dirs = split("/", $dir);
		my $path = "";
		foreach (@dirs) {
			$path .= "/".$_;
			if ( ! -d $path ) {
				if (! mkdir $path, $UMASK) {
					mylog("Can't create directory %s.", $path);
					return 0;
				}
			}
		}
	}
	return 1;
}

# create filename with full path from ident and timestamp
# @ident 
# @timestamp
sub datafile_mkname($$) {
	my ($ident, $ts) = @_;

	$ident = lc($ident);

	return strftime("$DATADIR/$ident/%Y-%m.xmdb", localtime($ts));
}

# open datafile or create new file and data structures it it's nessesary
# @ filename
# @ @columns for newly created file
# return false or DB file handle
sub datafile_init {
	my ($datafile, @cols) = @_;

	my $newfile = 0;

	# datafile don't exist
	if ( ! -f $datafile ) {
		$newfile = 1;
		# create imediate directiries
		mkdatadir($datafile) || return 0;
	}

	# connect to datafile
	my $dbh = DBI->connect("dbi:SQLite:dbname=$datafile");
	my $foo = $dbh->{private_datafile};
	$foo ||= $dbh->{private_datafile} =  $datafile;

	if (!$dbh) {
		mylog("Can't open to datafile %s (%s).", $datafile,  $DBI::errstr);
		return 0;
	}
	debug(15, "Database %s connected.", $datafile);
	sqldo($dbh, "PRAGMA synchronous = OFF;");
	sqldo($dbh, "BEGIN TRANSACTION;");

	# create new basic data structure on newly created file
	if ($newfile) {
		# create tables
		sqldo($dbh, "CREATE TABLE IF NOT EXISTS DATA 
					(`TIMESTAMP` TIMESTAMP NOT NULL PRIMARY KEY, 
					`INTERVAL` INT)") || return 0;
		sqldo($dbh,"CREATE TABLE IF NOT EXISTS INFO 
					(`TIMESTAMP` TIMESTAMP NOT NULL, INFO TEXT)") || return 0;
		delete($STRUCTCACHE{$datafile});
		$STRUCTCACHE{$datafile}->{INTERVAL} = 1;
		datafile_updatestruct($dbh, $datafile, @cols) || return 0;
		debug(25, "New data structures in %s succesfully prepared.", $datafile);
	} else {
		# if file allready exist and data structure doesn't exist in $STRUCTCACHE
		if (!defined($STRUCTCACHE{$datafile})) {
			debug(25, "Loading data structure from %s.", $datafile);
			my $tbh = $dbh->prepare("PRAGMA table_info(DATA)");	
			if ($tbh->execute()) {
				while (my ($order, $column) = $tbh->fetchrow_array()) {
					$STRUCTCACHE{$datafile}->{$column} = $order;
				}
			} else {
				mylog("Can't load data structure from %s.", $datafile);
				return 0;
			}
		}
	}
	return $dbh;
}

# update structures in datafile
# @ dbh
# @ @collumns
# return 0 | 1 - success
sub datafile_updatestruct {
	my ($dbh, $datafile, @cols) = @_;

	# Add missing fields (on new created table all fields)
	if (@cols > 0) {
		foreach (@cols) {
			sqldo($dbh, "ALTER TABLE DATA ADD `$_` DOUBLE") || return 0;
			$STRUCTCACHE{$datafile}->{$_} = 1;
			debug(25, "Column %s succesfully added.", $_);
		}
	}
	return 1;
}

# update info information (check if new value is differend from previous. If it is true append new info)
# @ dbh
# @ ident
# @ ts
# @ text info (in concatenated base64)
sub datafile_updateinfo($$$$) {
	my ($dbh, $ident, $ts, $info) = @_;

	# process INFO field
	$info =~ s/:/\n/;
	$info = decode_base64($info);

	#find last value
	my $tbh;
	if (!($tbh = $dbh->prepare("SELECT INFO FROM INFO ORDER BY `TIMESTAMP` DESC LIMIT 1"))) {
		mylog("Can't prepare query for %s (%s).", $ident, $DBI::errstr);
		return 0;
	}
	if (!$tbh->execute()) {
		mylog("Can't load info data structure %s (%s).", $ident,  $DBI::errstr);
		return 0;
	}

	while (my ($dinfo) = $tbh->fetchrow_array()) {
		if ($dinfo eq $info) {
			debug(25, "Last info record same as new. Skipping.");
			return;
		}
	}
	debug(25, "Adding new INFO record for %s.", $ident);
	sqldo($dbh, "INSERT INTO `INFO` (`TIMESTAMP`, `INFO`) VALUES (%d, %s)", $ts, $dbh->quote($info));
	
}

# Store %DATA structure into databse for one ident
# @ident
# return 1 - success; 0 - failed (some errors)
sub store_data($) {
	my ($ident) = @_;

	my (%newcols, $dbh);
	my $datafile = "";
	my $count = 0;
	

	foreach my $ts (sort keys %{$QDATA{$ident}}) {

		my $new_datafile = datafile_mkname($ident, $ts);

		# we will use new file
		if ($new_datafile ne $datafile) {
			$datafile = $new_datafile;
			if (defined($dbh)) {
				sqldo($dbh, "END TRANSACTION;");
				$dbh->disconnect();
			}
			$dbh = datafile_init($datafile);
		}

		# process INFO field
		if (defined($QDATA{$ident}->{$ts}->{INFO})) {
			datafile_updateinfo($dbh, $ident, $ts, $QDATA{$ident}->{$ts}->{INFO});
		}

		my %data;
		my $anydata = 0;
		# process fields
		foreach my $field (sort keys %{$QDATA{$ident}->{$ts}}) {

			# skip INFO field
			next if ($field eq "INFO");
			next if ($field eq "SOURCE");

			if (!defined($AT{$field}->{DS_TYPE}) && $field ne "INTERVAL") {
				mylog("DS_TYPE definition for %s not found in %s. Field ignored.", $field, $ATTMAP);
				next;
			} 

			# check if field exist in file
			if (!defined($STRUCTCACHE{$datafile}->{$field})) {
				datafile_updatestruct($dbh, $datafile, $field) || return 0;
			}
			
			$data{$field} = $QDATA{$ident}->{$ts}->{$field};
			$anydata = 1;
		}
		if ($anydata) {
			my $rc = sqldo($dbh, "INSERT OR REPLACE INTO `DATA` (`TIMESTAMP`, %s) VALUES (%d, %s) ", 
					join(", ", keys %data), $ts, join(",", values %data));
			if ($rc) {
				$count++;
			} else {
				mylog("Data store failed db=%s source=%s ts=%s", $datafile, $QDATA{$ident}->{$ts}->{SOURCE}, $ts);
			}
		} else {
			mylog("Empty data set for %s.", $ident);
		}
	}
	delete($QDATA{$ident});

	sqldo($dbh, "END TRANSACTION;");
	$dbh->disconnect();
	debug(20, "Datafile closed.");
	return $count;

}

# process data in QUEUE
sub run_queuerunner() {

	my $rows = 0;

	if (!chdir $QUEUEDIR) {
		mylog("QEUERUNNER: Can't change directory to %s.", $QUEUEDIR);
		return;
	}

	my $reccnt = 0;
	foreach my $file (sort { $a cmp $b } glob("*")) {
		# skip files with dot in name (temporary files)
		next if ($file =~ /\./);

		if ($reccnt > $QUEUELIMIT) {
			mylog("Records number (%d) is greater tahen QUEUELIMIT (%d). Rest records will be process in next step.", $reccnt, $QUEUELIMIT);
			last;
		}

		if ($file =~ /^([-\-\@\w.\:\/\d]+)$/) {
			$file = $1;
		} else {
			mylog("Invalid file name %s.", $file);
		}

		# open file
		if (open FQ, "< $file") {
			debug(10, "Processing QEUE file %s.", $file);
			my $cnt = 0;
			while (my $row = <FQ>) {
				chomp $row;
				parse_line($row, $file);
				$cnt++;
			}
			$reccnt += $cnt;
			debug(10, "Loaded %d records from QEUE file %s.", $cnt, $file);
			close FQ;
		} else {
			mylog("Can't open %s from queue.", $file);
		}
		unlink($file) || mylog("Can't unlink file %s.", $file);
	}	
	foreach my $ident (keys %QDATA) {
		my $tm = time();
		debug(10, "Storing %s.", $ident);
		$rows += store_data($ident);
		debug(10, "Data for %s stored in %s secs, %d records.", $ident, time() - $tm, $rows);
	}

	return $rows;
}

# parse one input line
# @ input line
# @ filename from queue
# return 1 (success) or 0 (error)
#
# Line must have follow format:
# DATA <tab> name <tab>  KEY:VALUE <tab> KEY:VALUE <tab> ...
sub parse_line($$) {
	my ($row, $file) = @_;

	chomp $row;
	#DATA     hp-pur.5        IN_PKTS:69192135        OUT_OCTETS:229970874    IN_OCTETS:3804236604    OUT_PKTS:69183598       TIMESTAMP:1181812175	INFO:<base64text>:<b64>:<b64>
	if ($row =~ /^DATA\t(.+?)\t(.+)$/) {
		my $ident = $1;
		my @values = split(/\t/, $2);
		my ($ref, $ts);

		# test zda $ident neobsahuje nepolvolene znaky pripadne symbol ..
		if ($ident !~ /[a-zA-Z0-9\.\-\:]+/) {
			mylog("Invalid character in %s.", $ident);
			return 0;
		}
		if ($ident =~ /\.\./) {
			mylog("Invalid .. found in %s.", $ident);
			return 0;
		}
		foreach (@values) {
			my ($key, $val) = split(/\:/, $_, 2);
			$ref->{$key} = $val;
		}
		# process TIMESTAMP field
		if (defined($ref->{TIMESTAMP})) {
			$ts = $ref->{TIMESTAMP};
			delete($ref->{TIMESTAMP});
		} else {
			mylog("Missing TIMESTAMP field %s (row: %s). Records ignored.", $file, $row);
			return 0;
		}

		# put data into data structure	
		$ref->{SOURCE} = $file;
		$QDATA{$ident}->{$ts} = $ref;
	} else {
		mylog("Invalid input data from %s (row: %s).", $file, $row);
		return 0;
	}
}

# convert IP address to hex value
sub hexaddr($) {
	my ($addr) = @_;

	my $res = "";
	
	my @arr = split(/[\.|\:]/, $addr);
	foreach (@arr) {
		$res .= sprintf("%03d", $_);
	}
	return $res;
}

# Lestener thread
sub run_listener() {

	$SIG{CHLD} = 'IGNORE';

	my $base_sock = new IO::Socket::INET( LocalPort => $PORT,
   	                           Proto => 'tcp',
   	                           Listen => 5,
   	                           Resue => 1);
	mylog("LISTENER: Can't create socket. $!\n") unless($base_sock);
	mylog("LISTENER: Listening on $PORT.");

	while (my $sock = $base_sock->accept()) {
		my $pid = fork();
		mylog("Can't fork process $!.") unless defined($pid);
		if ($pid == 0) {
			$SIG{CHLD} = '';

			# test number of connected clients and close socket if the number if > 20 
			my $numproc = `ps ax | grep xmon-server | wc |cut -c1-7`;
			chomp $numproc;
			if ($numproc > 35 ) {
				mylog("LISTENER: Too many process run (%s), skipping client  (%s)", $numproc, $sock->peerhost());
				close $sock;
				exit(0);
			}
			my $start = time();
			debug(5, "LISTENER: Client connected from %s.", $sock->peerhost());
			my $fname = sprintf("%s/%s-%06d-%s", $QUEUEDIR, strftime("%Y%m%d%H%M%S", localtime()), $$, hexaddr($sock->peerhost()));
			my $fname2 = "$fname.tmp";
			my $okcnt = 0;
			my $failcnt = 0;
			if (!open F1, ">> $fname2") {
				mylog("Can't open file %s for write.", $fname2);
				close $sock;
				last;
			}
			while (my $row = <$sock>) {
				chomp $row;
				if ($row ne "") {
					print F1 $row."\n";
					print $sock "OK\n";
					$okcnt++;
				} else {
					mylog("LISTENER: Empty data line (%s)", $row);
				}
			}
			close F1;
			if (!rename($fname2, $fname)) {
				mylog("LISTENER: Can't rename %s to %s.", $fname2, $fname);
			} else {
				debug(5, "LISTENER: Stored %d records in queue (%s)  peer %s in %d sec.", $okcnt, $fname, $sock->peerhost(), time() - $start);
			}
			exit(0);
			close $sock;
		}
	}
	close $base_sock;
}

# help
sub usage() {
	printf "Linemom daemon\n";
	printf "Usage:\n";
	printf "    %s -d <debug_level> -u <username> -q <queue process time>\n", $0;
	exit 1;
}

# Hlavni telo 
$SIG{CHLD} = sub { wait(); };

if (!getopt("d:u:q:", \%OPTS) || defined($OPTS{"?"})) {
	usage();	
	exit 1;
}

if (defined($OPTS{"d"})) {
	$DEBUG = $OPTS{"d"};
}

if (defined($OPTS{"u"})) {
	chuser($OPTS{"u"});
}

if (defined($OPTS{"q"})) {
	$QUEUERUN = $OPTS{"q"};
}

if ($DEBUG == 0) {
	daemonize();
}

mylog("Server started with debug level %d, version %s.", $DEBUG, $VERSION);
my $pid = fork();
mylog("Can't fork process $!.") unless defined($pid);
if ($pid == 0) {
	mylog("Running queuerunner loop with period %d.", $QUEUERUN);
	load_attmap();
	for (;;) {

		# run a queue process as the seperate process to save a memory
		if (my $pid = fork()) {
			waitpid($pid, 0);
		} else {
			my $tm = time();
			debug(3, "Running queuerunner.");
			my $rows = run_queuerunner();
			debug(3, "Data from queue stored in %d secs, %d records.", time() - $tm, $rows);
			exit 0;
		}

		sleep($QUEUERUN * 60);
		sleep(1);
	}
}

run_listener();

